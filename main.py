from pydantic import BaseModel
import pandas as pd
import joblib
import numpy as np
import os
import io
import uuid
import math
import tempfile
from datetime import datetime
from collections import deque

# FastAPI and middleware setup
from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import FileResponse, JSONResponse, StreamingResponse

# PDF and charting stuff
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import mm
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table,
    TableStyle, Image
)
from reportlab.lib import colors
from reportlab.lib.styles import ParagraphStyle
from reportlab.lib.utils import ImageReader
from reportlab.lib.enums import TA_LEFT

import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

# Fire up the app
app = FastAPI()

# CORS - for when stuff needs to talk across domains (mostly dev)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Note: consider narrowing this in prod
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Load model 
clf = joblib.load("rf_model.joblib")
le = joblib.load("label_encoder.joblib")

# Global state holders 
latest_result = {}
EVENTS = deque(maxlen=1000)

# Input model schema
class Features(BaseModel):
    features: dict

# Define some default styles (just quick theme setup for pdf)
TITLE = ParagraphStyle(name="TITLE", fontName="Helvetica-Bold", fontSize=20, spaceAfter=8)
H2 = ParagraphStyle(name="H2", fontName="Helvetica-Bold", fontSize=14, spaceBefore=10, spaceAfter=4)
BODY = ParagraphStyle(name="BODY", fontName="Helvetica", fontSize=10)
MONO = ParagraphStyle(name="MONO", fontName="Courier", fontSize=9)

# mapping from attack names to descriptions (basically mini knowledge base)
def _kb_for_attack(attack_type):
    KB = {
        "BENIGN": {
            "what": "Normal, non-malicious network traffic.",
            "indicators": [
                "Expected communication patterns",
                "No anomalies detected in flow statistics",
                "Baseline system activity"
            ],
            "mitigations": [
                "No action required",
                "Continue monitoring for anomalies"
            ]
        },
        "Bot": {
            "what": "Traffic generated by infected hosts acting under external control.",
            "indicators": [
                "Unusual outbound connections to C2 servers",
                "Regular beaconing patterns",
                "Unexplained automated requests"
            ],
            "mitigations": [
                "Isolate suspected machines",
                "Run endpoint malware scans",
                "Block known C2 domains/IPs"
            ]
        },
        "DDoS": {
            "what": "Distributed Denial of Service attack flooding resources from many sources.",
            "indicators": [
                "Massive spike in traffic volume",
                "Connections from a wide range of IPs",
                "Sustained bandwidth/CPU saturation"
            ],
            "mitigations": [
                "Use DDoS protection service or CDN",
                "Rate limiting and filtering",
                "Traffic scrubbing upstream"
            ]
        },
        "DoS GoldenEye": {
            "what": "Denial of Service via HTTP keep-alive and header abuse.",
            "indicators": [
                "Large number of incomplete HTTP requests",
                "Connections that remain open unusually long",
                "Spike in CPU usage on web server"
            ],
            "mitigations": [
                "Deploy HTTP flood detection at WAF",
                "Limit concurrent connections per IP",
                "Terminate slow/incomplete requests"
            ]
        },
        "DoS Hulk": {
            "what": "High-rate HTTP flooding intended to exhaust server resources.",
            "indicators": [
                "Sudden increase in repetitive GET requests",
                "Same URL requested excessively",
                "High error rate from web server"
            ],
            "mitigations": [
                "Rate limiting or request throttling",
                "Block offending IPs at firewall",
                "Autoscale backend servers"
            ]
        },
        "DoS Slowhttptest": {
            "what": "Denial of Service using slow headers or body to hold connections open.",
            "indicators": [
                "Numerous half-open HTTP connections",
                "Requests with incomplete headers",
                "Server thread pool exhaustion"
            ],
            "mitigations": [
                "Set aggressive timeouts for headers/body",
                "Limit connections per client",
                "Deploy WAF signatures for slowloris-style attacks"
            ]
        },
        "DoS slowloris": {
            "what": "Denial of Service that sends partial HTTP requests slowly to keep connections alive.",
            "indicators": [
                "High count of open but idle connections",
                "Very slow header transmission rates",
                "Resource exhaustion on web servers"
            ],
            "mitigations": [
                "Use reverse proxies or CDNs with timeout enforcement",
                "Limit client header transmission times",
                "Enable SYN cookies and request throttling"
            ]
        },
        "FTP-Patator": {
            "what": "Brute-force attack against FTP service.",
            "indicators": [
                "Multiple failed FTP login attempts",
                "High rate of connection resets",
                "Sequential username/password attempts"
            ],
            "mitigations": [
                "Enable account lockouts after failed attempts",
                "Use strong authentication (e.g., key-based)",
                "Monitor and block offending IPs"
            ]
        },
        "Heartbleed": {
            "what": "Exploit of OpenSSL heartbeat extension to read memory contents.",
            "indicators": [
                "Abnormal TLS heartbeat requests",
                "Unusual length fields in TLS packets",
                "SSL errors on affected servers"
            ],
            "mitigations": [
                "Patch vulnerable OpenSSL versions",
                "Rotate exposed keys/certificates",
                "Monitor for anomalous TLS heartbeat traffic"
            ]
        },
        "Infiltration": {
            "what": "Traffic from attackers breaching into internal network systems.",
            "indicators": [
                "Unexpected inbound connections",
                "Data exfiltration over uncommon ports",
                "Usage of tunneling or VPN from unknown sources"
            ],
            "mitigations": [
                "Tighten firewall inbound rules",
                "Monitor outbound connections for anomalies",
                "Deploy intrusion detection/prevention systems"
            ]
        },
        "PortScan": {
            "what": "Systematic probing of ports to discover open services.",
            "indicators": [
                "Rapid sequential connection attempts across ports",
                "Repeated SYN packets without completion",
                "High number of destination port variations"
            ],
            "mitigations": [
                "Block scans at firewall/IPS",
                "Use tarpitting to slow scanners",
                "Monitor logs for reconnaissance attempts"
            ]
        },
        "SSH-Patator": {
            "what": "Brute-force attack against SSH service.",
            "indicators": [
                "Multiple failed SSH login attempts",
                "Frequent authentication errors in logs",
                "Sequential username/password attempts"
            ],
            "mitigations": [
                "Enable fail2ban or similar tools",
                "Use key-based authentication",
                "Restrict SSH access by IP/port knocking"
            ]
        },
        "Web Attack - Brute Force": {
            "what": "Brute-force attack against web application login pages.",
            "indicators": [
                "Repeated login failures from same IP",
                "Many authentication attempts in short time",
                "Lockout triggers in application logs"
            ],
            "mitigations": [
                "Account lockout policies",
                "CAPTCHA after failed attempts",
                "WAF rules against brute-force patterns"
            ]
        },
        "Web Attack - Sql Injection": {
            "what": "Injection of SQL into inputs to manipulate backend queries.",
            "indicators": [
                "Requests containing SQL keywords or operators",
                "Database error messages in responses",
                "Abnormal queries reaching backend"
            ],
            "mitigations": [
                "Parameterized queries / prepared statements",
                "Sanitize and validate inputs",
                "WAF rules for SQLi signatures"
            ]
        },
        "Web Attack - XSS": {
            "what": "Injection of malicious scripts into web pages viewed by others.",
            "indicators": [
                "User input reflected without sanitization",
                "Presence of <script> tags or event handlers",
                "Encoded payloads in query strings"
            ],
            "mitigations": [
                "Output encoding and CSP headers",
                "Sanitize user input",
                "Apply WAF rules for XSS patterns"
            ]
        },
        "_default": {
            "what": "Malicious or suspicious traffic pattern detected.",
            "indicators": ["Model confidence exceeded threshold for this class."],
            "mitigations": [
                "Validate indicators against raw logs",
                "Tighten least-privilege/WAF rules"
            ]
        }
    }
    return KB.get(attack_type) or KB["_default"]

# Turn feature dict into a table for the report (could probably be simplified)
def _features_table(feature_dict, max_cols=2):
    items = list(feature_dict.items())
    rows, cols = [], []
    chunk_len = math.ceil(len(items) / max_cols)

    for col_index in range(max_cols):
        chunk = items[col_index * chunk_len:(col_index + 1) * chunk_len]
        col_cells = [
            [Paragraph(f"<b>{k}</b>", BODY), Paragraph(str(v), MONO)]
            for k, v in chunk
        ]
        cols.append(col_cells)

    for row_index in range(max(len(c) for c in cols)):
        row = []
        for col in cols:
            row.extend(col[row_index] if row_index < len(col) else ["", ""])
        rows.append(row)

    table = Table(rows)
    table.setStyle(TableStyle([
        ("GRID", (0, 0), (-1, -1), 0.25, colors.HexColor("#e5e7eb")),
        ("VALIGN", (0, 0), (-1, -1), "TOP"),
        ("LEFTPADDING", (0, 0), (-1, -1), 4),
        ("RIGHTPADDING", (0, 0), (-1, -1), 4),
        ("TOPPADDING", (0, 0), (-1, -1), 3),
        ("BOTTOMPADDING", (0, 0), (-1, -1), 3),
    ]))
    return table

# Create a PDF from an event's details
def _build_report_to_bytes(event):
    buffer = io.BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4,
                            leftMargin=15*mm, rightMargin=15*mm,
                            topMargin=15*mm, bottomMargin=15*mm)
    story = []

    story.append(Paragraph("Cyber Attack Detection Report", TITLE))
    event_meta = (
        f"<b>Generated:</b> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}<br/>"
        f"<b>Event ID:</b> {event.get('id','')}<br/>"
        f"<b>Detected at:</b> {event.get('ts','')}<br/>"
        f"<b>Attack Type:</b> {event.get('attack_type','')}<br/>"
        f"<b>Confidence:</b> {float(event.get('confidence', 0)) * 100:.2f}%<br/>"
        f"<b>Model:</b> Random Forest<br/>"
        f"<b>Source:</b> Simulated environment (CIC + some real-world features)"
    )
    story.append(Paragraph(event_meta, BODY))
    story.append(Spacer(1, 6 * mm))

    # attack knowledge block
    kb = _kb_for_attack(event.get("attack_type", ""))
    story.append(Paragraph("Attack Overview", H2))
    story.append(Paragraph(kb.get("what", ""), BODY))

    story.append(Paragraph("Common Indicators", H2))
    for ind in kb.get("indicators", []):
        story.append(Paragraph(f"• {ind}", BODY))

    story.append(Paragraph("Recommended Mitigations", H2))
    for fix in kb.get("mitigations", []):
        story.append(Paragraph(f"• {fix}", BODY))
    story.append(Spacer(1, 6 * mm))

    # bar chart (needs fixing, not being generated)
    try:
      numeric = []
      for k, v in (event.get("features") or {}).items():
          try:
              fv = float(v)
              if math.isfinite(fv):
                  numeric.append((k, fv))
          except:
              pass

      if numeric:
          numeric.sort(key=lambda kv: abs(kv[1]), reverse=True)
          top = numeric[:10]
          labels = [k for k, _ in top][::-1]
          vals = [v for _, v in top][::-1]

          plt.figure(figsize=(6, 3))
          plt.barh(range(len(vals)), vals)
          plt.yticks(range(len(labels)), labels, fontsize=8)
          plt.xlabel("Value")
          plt.tight_layout()

          img_buf = io.BytesIO()
          plt.savefig(img_buf, format="png", dpi=180)
          plt.close()
          img_buf.seek(0)

          story.append(Paragraph("Top Numeric Features (by magnitude)", H2))
          story.append(Image(ImageReader(img_buf), width=160*mm, height=70*mm))
          story.append(Spacer(1, 6*mm))
    except Exception as e:
        print(f"Chart generation error for event {event.get('id')}: {e}")


    # snapshot of raw features (raw dump basically)
    story.append(Paragraph("Feature Snapshot", H2))
    story.append(Paragraph("These are the key:value pairs captured at the time of detection.", BODY))
    story.append(Spacer(1, 2 * mm))
    story.append(_features_table(event.get("features") or {}, max_cols=2))

    doc.build(story)
    return buffer.getvalue()

# endpoint to download a report PDF by event ID
@app.get("/reports/{event_id}")
def download_report(event_id: str):
    event = next((e for e in EVENTS if e["id"] == event_id), None)
    if not event:
        print(f"Event {event_id} not found. Total events in memory: {len(EVENTS)}")
        raise HTTPException(status_code=404, detail="Event not found")

    try:
        pdf_data = _build_report_to_bytes(event)
        filename = f"attack_report_{event_id}.pdf"
        return StreamingResponse(
            io.BytesIO(pdf_data),
            media_type="application/pdf",
            headers={"Content-Disposition": f'attachment; filename="{filename}"'}
        )
    except Exception as e:
        print(f"Report build failed for event {event_id}: {e}")
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="PDF generation failed")

# Normalize weird label characters
def normalize_label(label: str) -> str:
    return label.replace("�", "-").strip()

# Attack detection endpoint — the real action happens here
@app.post("/detect")
def detect_attack(data: Features):
    global latest_result

    df = pd.DataFrame([data.features])
    pred = clf.predict(df)[0]
    prob = clf.predict_proba(df)[0][pred]
    attack_type = normalize_label(le.inverse_transform([pred])[0])
    confidence = float(np.round(prob, 3))

    event = {
        "id": str(uuid.uuid4()),
        "ts": datetime.utcnow().isoformat() + "Z",
        "attack_type": attack_type,
        "confidence": confidence,
        "features": data.features,
    }
    EVENTS.append(event)
    latest_result = {k: event[k] for k in ("id", "ts", "attack_type", "confidence")}

    return latest_result

# Fetch recent events (default: last 100)
@app.get("/events")
def list_events(limit: int = 100):
    return {"events": list(reversed(list(EVENTS)[-limit:]))}

# Quick helper for polling latest detection
@app.get("/latest")
def get_latest():
    return latest_result or {"attack_type": "None", "confidence": 0.0}
